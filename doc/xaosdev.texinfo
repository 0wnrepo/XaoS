\input texinfo   @c -*-texinfo-*-

@c Use A4 paper - If you don't like that, remove the following 3 lines.
@iftex
@afourpaper
@end iftex

@setfilename xaosdev.info
@settitle An fast real-time interactive fractal zoomer---hacker's guide
@dircategory Graphics
@direntry 
 * XaoS: (xaosdev).               The fast real-time interactive fractal zoomer
                                  (developers documentation
@end direntry


@ifinfo
@copyright{} 1997 Jan Hubicka

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

@end ifinfo

@c %**end of header

@set VERSION    3.1
@set DATE       May 14, 1998

@titlepage

@title{XaoS @value{VERSION}}
@subtitle{An fast real-time fractal zoomer---hacker's guide}

@author{Jan Hubi@v cka}
@tex
Dukelsk\'ych bojovn\'\i ku 1944 
@end tex
@*
390 03 T@'abor @*
Czech Republic

Email: @code{hubicka@@paru.cas.cz}

@value{DATE}

@page
@vskip 0pt plus 1filll
@vskip 0pt plus 1filll

@copyright{} 1997 @tex Jan Hubi\v cka 
@end tex

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

@end titlepage

@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@node   Top,    ,       (dir),  (dir)

@ifinfo
@top XaoS @value{VERSION}
@flushright 1.0
An real-time interactive fractal zoomer
Hacker's guide
@value{DATE}
@end flushright

This manual contains documentation for those who are interested in
studying and improving XaoS sources or using them in other programs. 
It includes description of algorithm and documentation of those parts
of XaoS I think they should be useful for someone.
@end ifinfo

@menu
* design::		Overview of the XaoS design
* driver::		Driver API description
* gui-driver::		Writing user interface driver
* eui::			Writing an external user interface
* ui-helper::		UI helper library
* xthreads::		XaoS thread library
* filters::		Filters
* algorithm::		Algorithm description
* timerlib::		The timer library
* registry::		XaoS function registry
* index::		Function command and variable index
@end menu

@node design, driver ,Top ,Top
@chapter Overview of the XaoS design

Whole sources of XaoS are designed into several ``libraries'' (some of them
are not really libraries, but added into other's, but should be separated
easily). 

Understanding to the main philosophy should help you to navigate in the sources. 
I also expect that many of the lower level stuff should be useful in the
other projects, since it is designed to be fairly generic.

So here is an overview from the lowest level stuff to the highest.

@section Palette and image library

@findex image
@findex palette
Sources are in directory @code{src/filter}. The aim of palette
library is to provide relatively abstract interface to the various visuals and
hide differences in the hardware and driver implementation. Fixedcolor, pseudocolor,
grayscale and truecolor visuals should be handled in the almost same way.

It provides the structure @code{palette}, which contains actual palette.
You might allocate new colors here (you give RGB value and corresponding pixel
is returned), interpolate colors where possible, cycle colors and so on.
Every palette also consist from the two parts---the preallocated color cells
and the actual palette. This lets for example to GUI possibility to allocate
statically colors for its texts and dialogs, while rest of palette is under
control of different parts of XaoS.

This library also contain set of functions to allocate different palettes
used by other parts. I expected that different parts of XaoS should use same
palette. Nothing similar happened yet, but functions are kept here.

The image library is built at the top of palette library. It extends
functionality for handling actual image data. Each image is represented by one
or two frame-buffers (it is useful for double-buffering). One frame-buffer is
called current and other old. They should be flipped by special function.
Program can draw into both of them.

Frame-buffers are hold as the set of pointers to the scan-lines. This brings better
flexibility, because tricks like sub-windows, or flipped bitmaps are possible. Also speeds
up, since you should avoid one multiplication.

The last significant information image structure hold is of course bpp depth.
It is counted in bytes, and should be 0--4. Where 0 is used for 1bit
bitmaps.

@section Filter library
Source are available in @code{src/filter}. This library controls the process
of creation of the image. It handles an queue of the filters, where each
filter should modify the image. There are two special filter at the beginning
and end of queue. The first filter is usually the actual fractal engine which
creates image, while the terminal filter is usually user interface helper
library.

@section Xthread library
This library provides interface to various multi-threading libraries (currently
the BeOS, plan9 and POSIX implementations are available). It allows to run
various function paraelly and some synchronization primitives (semaphores). It
is simple, but has all the functionality required for the XaoS engine.

@section Fractal library
Source are available in @code{src/engine/}, headers in @code{fractal.h}. 
This library contains the actual fractal calculation routines. It operates
with fractal context, which contains informations like current formula, seed
for julia, palette etc.

Functions for calculating the various fractal types and various coloring modes
are available here.

@section Zooming engine and other filters.
Source are available in @code{src/engine/}.
This is the actual zooming engine filter. It is done in fairly independent
way at fractal library, so it should be possibly used for zooming other stuff.
(it was already used for zooming large scale images containing maps of
Hungary).

All other filter has their special file, where is implementation and structure
containing all functions exported from the filter to user interface. They are
registered in the file @code{ui_helper}.
One other terminal filter is implemented---Julia morpher. Other filters adds
special effects (such as motion blur), or does conversions (such as rotation,
dithering etc.)

@section Timer library
This library provides many of very useful timing primitives. Such as
timers, etc. Currently it is used by some other programs too.

@section xio library
This library aims to provide united interface to file-system. Some strange
systems (such as MacOS) has file-system API done in much different way than
in UNIX. They don't have names in string, and uses special structures etc.

@section xshl library
Xshl stands for XaoS simple hypertext library. It contains fairly universal
engine parsing an xshl language. It is similar to HTML with some additions and
many restrictions. It should render this texts for the
proportional/non-proportional fonts and various sizes.

@section help library
it is built at the top of xshl and xio libraries. It should read help files,
wick contains an chapters. Parse chapter with given keyword etc.

@section xmenu library
This is the XaoS function registry. All functions from UI-Helper library are
registered in the registry. From this registry the menus, dialogs, command
line options and scripting language are built.

@section Catalog library
This is library for handling an message catalogs. It should read catalog and
convert the keyword into actual message.

@section PNG library
This library provides the function for saving an image from Image library to
the file (in PNG format). Other formats should be added as well if required.

@section UI-helper library
This library controls all the low-level stuff and provides an high level
interface to it. It has functions for playing animations, zooming/UN-zooming
and such. It heavily uses all the described libraries. It don't implement
functions for handling menus and such, but makes great help for such
implementations, because of the function registry database.

@section Ugly interface
This is currently the only real user interface for XaoS (there is also an second,
wich is used for rendering animations, but it is not user interface, how users
expect it). It is built at the top of UI-helper
library and provides functions for drawing menus, dialogs and such.
It has drivers for many platforms, and it should be easily ported to the
others.

In the future, it should be quite easily to extended to let
drivers specify their own menu/dialog handling code, so it should be possible
to give it an ``native'' look of given platform.

It has also an function, where an GUI drawing routines are disabled. Function
registry database is transfered trough pipe to external program, wick should
build the menus and act as external user interface. It then back sends an
commands in the scripting language representing things, that user done.
So it is an another way, how to give native look to ugly interface.

Ugly interface has also one serious limitation---for the historical reasons it
is coded to handle just one window (rest of XaoS probably can do
multiple windows---untested). So in windowed environments it is impossible to
open multiple menus with fractals. At the other hand, this limitation is not
so important, once external GUI enter the role. They should just start
multiple XaoS engines. This will bring extra robustness, multitasking and some
other advantages, so it is the proffered way. Thats why I don't plan to remove
this limitation yet.

@node driver, gui-driver ,design ,Top
@chapter Driver API description

To port successfully XaoS to some platform you need:

@itemize @bullet
@item
ANSI C compatible optimizing compiler. Note that optimizing compiler is really
required, since XaoS is coded to be good target for optimizations and don't
have any routines coded in assembly, so if you will use some bad compiler, you
should receive more than ten times slower result. Also note that some
compilers has serious problems with compiling XaoS---like most of DOS compilers
(Watcom C, Borland C, Microsoft C etc...), has serious problems.
They generate incorrect code or crash during compilation. I highly recommend
to use GNU C compiler. Even some versions of GNU C has problems. Please read
@code{compilers.txt} for more information.
@item
Fast way to avoid division by zero/overflow and other floating point
exception. XaoS is carefully coded to not to crash in this case, but don't
have any tests to avoid such situation and expect random result in such case.
Many platforms provide way to switch coprocessor into mode, where 1/0 is
evaluated into Inf etc. If there is no such way, try to use some kind of signal
handler that will ignore such exceptions.

The ``normal'' solution---add ifs to avoid division by zero is almost
impossible. The division is quite easy to check. But other cases---overflows
are much worse. So I don't think it is possible to avoid all crashes just by
adding ifs.

XaoS don't depend at IEEE arithmetic. Result in such cases should me mostly
undefined. XaoS usually works well with compiler's switches for inexact math
enabled (such as @code{-ffast-math} in GNU). But no guarantees. For example at
Alphas this is not true---since they usually generates exceptions then.
Also @code{-mno-ieee-fp} at Intel don't work. This is due to GCC bug. In some
cases it reverses the condition when this switch is enabled. I've made patch
to fix this bug and hope that it will get to egcs or gcc soon.
@item
Text or graphics output device. If you have only text output device, you may
use AA driver, which renders fractals into high quality ASCII art. In this case
you might skip this chapter, download AA-lib (http://www.ta.jcu.cz/aa) and
read porting chapter of AAlib manual. Graphics device must one of:

@findex C256
@findex FIXEDCOLOR
@findex GRAYSCALE
@findex TRUECOLOR
@findex TRUECOLOR24
@findex TRUECOLOR32
@itemize @bullet
@item 8bits per pixel with user definable palette @code{C256}, static palette @code{FIXEDCOLOR}, or static grayscale @code{GRAYSCALE}
@item 16bits per pixel with arbitrary bits per each color @code{TRUECOLOR}
@item 24bits per pixel with 8 bits per each color, arbitrary order @code{TRUECOLOR24}
@item 32bits per pixel with arbitrary order of colors, where each colors fit to exactly one byte @code{TRUECOLOR}
@item 1bits per pixel bitmap with both orders (Least or Most significant bit first)
@end itemize

Please contact me if you have different kind of device. Some modes (like
miss-ordered truecolor modes) should be added really easily if required.
Note that mono/4/16 colors devices will be probably never supported 
internally by XaoS, since I expect they will be slower than 8bpp, so XaoS
will internally work in 8bpp and then image should be converted. Contact me
if you want to write such converter. (For bitmap there already exists---see
@code{dither.c}.
@item
Some way to save images. By default XaoS uses @code{pnglib}, which is ported to many
platforms, but there is still many others. If your system has some standard
image format, which is easier to handle than @code{.png}, contact me and I will show
you, how to add such support to XaoS (see @code{png.c}).
@item
Stdio compatible library (this is problem at Mac or BeOS). XaoS has the
abstract layer at the top of stdio, so it should use other input/output
libraries too. You might write just another implementation if it's library
called @code{xio}. See @code{xio.h}.
@end itemize

Ugly interface is designed to make writing of new drivers as easy as possible.
You need to write just few functions to fill following table:
(use file @code{ui_template} for starting of writing new driver from scrath)
@findex ui_driver
@example
struct ui_driver @{
  char *name;
  int (*init)(void);            /*initializing function. returns 0 if fail*/
  void (*getsize)(int *,int *);	/*get current size..in full-screen versions
                                  i.e svga and dos asks user for it*/
  void (*processevents)(int,int *,int *,int *,int *);
                                /*processevents..calls ui_resize,ui_key
                                  also returns positions of mouse..
                                  waits for event if first parameter is
                                  1*/
  void (*getmouse)(int *,int *,int *);
                                /*returns current mouse positions*/
  void (*uninit)();             /*called before exit*/
  int (*set_color)(int,int,int,int);
                                /*alloc palette color and returns number*/
  int (*set_range)(ui_palette *palette,int start,int end)
                                /*Set palette range*/
  void (*print)(int,int,char *);/*prints text*/
  void (*display)();            /*displays bitmap*/
  int (*alloc_buffers)(char **buffer1,char **buffer2);/*makes buffers*/
  void (*free_buffers)(char *buffer1,char *buffer2);/*frees buffers*/
  void (*flip_buffers)(void);   /*prints text*/
  void (*mousetype) (int type); /*Change mouse cursor*/
  void (*flush) (void);         /*Flush current state to screen*/
  int textwidth;                /*width of text*/
  int textheight;		/*height of text*/
  struct params *params;        /*command line parameters*/
  int flags;
  float width,height;
  int maxwidth,maxheight;
  int imagetype;
  int palettestart,paletteend,maxentries;
  int rmask, gmask, bmask;
  struct gui_driver gui_driver;
@};
@end example

@section Functions

Ui uses following functions to communicate with driver:

@defun init
  function that initializes driver and returns 1 if success and 0 if fail
@end defun
@defun getsize (int *@var{width}, int *@var{height})
  returns size of screen(window) x and y
@end defun
@defun processevents (int @var{wait}, int *@var{x},int *@var{y}, int *@var{buttonmask}, int &@var{keys})
  gets new keyboard/mouse events. parameters:
  @table @var
  @item wait 
     if 1 function can wait for next event otherwise just lookup if 
           something came. This is useful on multi-tasked os where xaos
	   does not eats unnecesaru CPU.
  @item *x,*y  
    here returns current positions of mouse
  @item *b 
     returns mask of @code{BUTTON1},@code{BUTTON2},@code{BUTTON3} for mouse buttons
  @item *k 
    returns mask for cursor keys 
    @table @code
    @item 1 
    left
    @item 2 
    right
    @item 4 
    up
    @item 8 
    down
    @end table
    @end table
    function also calls @code{ui_key} (ASCII character) and ui_resize if required.
    For special keys use @code{UIKEY_UP}, @code{UIKEY_DOWN}, etc. See
    @code{ui.h} for complete lists of this constants.

    note in case of problems freeing/allocating inside processevents you may 
    call @code{ui_call_resize} that calls resize later outside this function
@end defun

@defun uninit
 Unitialises driver---called before exit.
@end defun

@defun set_range (ui_palette *@var{palette}, int @var{start}, int @var{end})
This is an preffered way to set palette (second way is @code{set_color})
when @code{imagetype} is @code{UI_C256} (256 color with palette) one of this
two functions is required. In truecolor modes they are unused. In case direct
access to palette is possible at your platform, define this one. Function is
expected to set all color cells between @var{start} to @var{end} to colors
defined in @var{palette}. @code{Ui_palette} is array of @var{ui_rgb}. @code{Palette[0]}
is color for entry number @var{start}. @code{Ui_rgb} is an array of @code{char}.
@code{Palette[0][0]} is red field of entry number @var{start}, @code{Palette[0][1]} is
green and @code{Palette[0][2]} is blue. @code{0} means black and @code{255}
means full intensity. Use @code{NULL} if your driver don't support this call.
@end defun

@defun set_color (int @var{r}, int @var{g}, int @var{b}, int @var{init})
  This is an secondary way, that should be used at platforms w/o direct
  palette access (like X11 or static color schemes). It receives RGB value
  of color, and returns index of color cell with this color or -1 if no more
  color cells available. An @var{init} parameter is set to 1, when first entry
  of palette is allocated, @code{set_color} is expected to free all color
  entries previously allocated. Use @code{NULL} if your driver don't support
  this call
@end defun

@defun print (int @code{x},int @code{y}, char *@code{text})
  prints text to screen at position x/y. This function is a bit archaistic
  (XaoS now uses in the most cases its own functions drawing directly to the
  buffer), but in some cases---initialization messages or calculation,
  functions are unusable, so we still need this primitive. In the @code{C256}
  mode you might rely, that first allocated color is always black and second
  is white.
@end defun

@defun display (void)
  displays current buffer to screen
@end defun

@defun alloc_buffers (char **@var{buffer1},char **@var{buffer2})
  allocs two buffers that can hold screen size bitmap. 
  Also sets current buffer to @var{buffer1}. Since version 2.1 returns scan-line 
  size in bytes(usually width) and 0 if fail. This is useful on systems, that
  allocated bitmap bigger than window/screen(dividable by 4 or so)
@end defun

@defun free_buffers (char *@var{buffer1}, char *@var{buffer2})
  frees allocated buffers
@end defun

@defun flip_buffer (void)
  flips buffers---set current buffer to other one
@end defun

@defun flush (void)
  This function should be used by drivers with buffered output to flush
  output buffers. Other driver should set it to NULL.
@end defun

@defun mousetype (int type)
   This function is used to change mouse cursor. It receives following values:
   @table @code
   @item NORMALMOUSE
     This mouse is usually displayed at screen, when UI waits for user
     commands
   @item WAITMOUSE
     This mouse is displayed when UI is busy(should be famous wait clocks)
     or you may use mouse defined in ui_dos---mandelbrot set
   @item REPLAYMOUSE
     This mouse is displayed during replay. Should be none at fullscreen
     drivers, since blinking mouse cursor during replay looks ugly. At
     windowed system disabling mouse looks ugly, so it should be some funny
     cursor.
   @end table
   You should use NULL if your driver don't support this.
@end defun

@section Other information
Also some additional variables are used to inform ui about driver.
All this values can be changed by init functions in case they are unknown
before.

@table @var
@item textheight, textwidth
  width and height of your font
@item palettestart, paletteend
  First and last palette entry, that should be changed. This you should use
  to avoid changing of entries reserved for window system, text, mouse etc.
@item rmask, gmask, bmask
  This fields are used in truecolor modes to specify, where each color is
  defined
@item maxentries;
  Number of allocatable entries. Normally should be
  @var{palettestart}-@var{paletteend}
@item imagetype
  defines type of image. Should be one of following values:
@findex UI_C256
@findex UI_FIXEDCOLOR
@findex UI_GRAYSCALE
@findex UI_TRUECOLOR
@findex UI_TRUECOLOR24
@findex UI_TRUECOLOR32
  @table @code
  @item UI_C256
    classical 256 color with palette scheme used by most older graphics
    adapters. You should use it also for static-color schemes but they are
    not supported well in current version.
  @item UI_TRUECOLOR
    32bpp truecolor mode
  @item UI_TRUECOLOR24
    24bpp truecolor mode. 
  @item UI_TRUECOLOR16
    16bpp truecolor mode 
  @end table
@end table



FOLLOWING PART IS NOT REQUIRED TO MAKE FIRST VERSION OF DRIVER WORKING.
so you may skip to REGISTERING DRIVER for first read and return here later.


@table @var

@item params
  Using this you may define command line options for you driver.

  They are defined using params structure like:
@findex params
  @example
  static struct params params[]=@{
    @{"-mode",P_NUMBER,&defmode,
      "Select graphics mode(same number as in interactive menu)"@},
    @{NULL,0,NULL,NULL@}  /*this is MUST be last option field*/
  @};
  @end example

  every line is one parameters. List ends with @code{@{NULL,0,NULL,NULL@}}.
  First filed is option name.
  Second field is type of parameter:
@findex P_SWITCH
@findex P_NUMBER
@findex P_STRING
@findex P_FLOAT
  @table @code
    @item P_SWITCH 
    no parameter---variable is just set to 1 if option
    @item P_NUMBER 
    integer number
    @item P_STRING 
    string
    @item P_FLOAT 
    floating point number (variable is float)
  @end table
  Third is pointer to variable that is changed if option is set. 
  It is for example @code{int*} for @code{P_NUMBER} or @code{P_SWITCH} and so on..
  Last one is help text. Displayed by @code{ui -h}


@item width,height
  see @var{flags}. May be set to @code{0.0, 0.0} for the beginning

@item maxwidth,maxheight
  see @var{flags}. May be set to 0,0 for the beginning

@item @var{flags}
  This variable says more about your driver. You may start with value 0.
  But for final version it is recommended to read following chapter carefully.

  Flags are uppercase constants and should be set by following way:

  @code{ASYNC_PALETTE | RANDOM_PALETTE_SIZE}

  following switches are supported:

  @table @code
@findex RANDOM_PALETTE_SIZE
@findex UPDATE_AFTER_RESIZE
@findex RESIZE_COMMAND
  @item RANDOM_PALETTE_SIZE
    random size of palette. This is used in X where palette is shared between
    programs. By default xaos allocates all available colors up to 256. This
    is not very nice to other applications in X. So randomsize causes that
    just some random number of colors(between 8-256) are allocated. 
  
    Also when this variable is off XaoS expects that allays same number of
    colors is available.
  @item UPDATE_AFTER_RESIZE
    recalculate and redraw screen even if its size is not changed.
    In case that resize procedure destroys data in buffers
  @item RESIZE_COMMAND
    Some drivers (mainly the fullscreen ones) may in the function @code{get_size}
    ask user for the size and color depth. It should be nice to let user change this parameter
    at runtime. I.E force XaoS to reinitialize his images. This is done by
    @code{ui_resize} call. This call in windowed drivers is called by the
    external event. But in fullscreen drivers you need key/menu item for this.
    You might add this function directly into XaoS's function registry (see
    for example the GGI driver)---it is usefull mainly when you want to make
    some size selection dialog in the standard way, or let XaoS add his default
    one. And this is done by this flag. See for example SVGAlib or DOG driver.
  @end table

  Screen/window size informations:

    Xaos needs to know exact size of displayed images. This is required
    for random dot stereo-grams and also for keeping fractals in their shape
    (do not make them wide on 640x200 resolution etc.)
    So minimally one of the following values should be defined.
    (they are sorted in order I prefer them)
@findex SCREENSIZE
@findex PIXELSIZE
@findex FULLSCREEN
@findex RESOLUTION
  @table @code
    @item SCREENSIZE
     values width/height specifies exact size of screen/window in centimeters
    @item PIXELSIZE
     values width/height specifies exact size of one pixel in centimeters
     This is better for windowed environments where window size is often changed
    @item FULLSCREEN
     driver runs fullscreen. XaoS automatically uses default screen size
     (29.0cm x 21.5cm)
    @item RESOLUTION
     driver does not know exact screen size. But knows resolution used.
     (it is in variables width/height) XaoS automatically calculates
     pixel width using:29.0cm/maxwidth
     and height: 21.5/maxheight
   @end table
   Of course default width and height can be changed by command line options.
   You may also use combinations like:
   
   @table @code
   @item SCREENSIZE | FULLSCREEN 
   the best for fullscreen drivers
   @item PIXELSIZE | RESOLUTION 
   the best for windowed drivers
   @item FULLSCREEN 
   for fullscreen drivers than have no idea about screen size...  
   @end table

   do not forget to set @var{width}, @var{height}, @var{maxwidth}, @var{maxheight} fields if required.

@item gui_driver
   See next section for description.
@end table


@section Registering driver

Than just register driver to @code{driver.c} and you may compile :)
You may use @code{ui_template.c} as driver template..

You may also look at xthreads library description if you are
porting XaoS to some SMP platform.

Please let me know if you want to start code some driver.

@node gui-driver, eui ,driver ,Top
@chapter Writting GUI driver

XaoS have builtin GUI. Many operating systems have native gui toolkits and
XaoS default GUI might look strange there. To avoid this problem, you might
write external gui program (see eui section) or write mappings of XaoS
GUI functions. The advantage of external gui process in multitasking.
XaoS is not thread safe and GUI must be synchronous with calculation.
Also ugly interface code currently don't support multiple windows (this should
be solved in future).
This solution is suitable mainly for those systems, where cooperation of two
programs sharing one window should be problem (like on Windows).

To write gui driver you need to fill following structure:
@example
struct gui_driver
@{
   void (*setrootmenu)(struct uih_context *c, char *name);
   void (*enabledisable)(struct uih_context *c, char *name);
   void (*menu)(struct uih_context *c, char *name);
   void (*dialog)(struct uih_context *c, char *name);
   void (*help)(struct uih_context *c, char *name);
@};
@end example

All function have @code{uih_context} parameter. You don't need to worry about
it's contents. Just pass it to the called functions that require it. This
parameter is for multiple window support, that is not implemented yet.

The @code{setrootmenu} function expected to draw root menu according to the
menu called @code{name}. To get menu fields you might use following piece of
code:
@example
#include <ui.h>
#include <xmenu.h>

....

int i;
menuitem *item;
for (i = 0; (item = menu_item (name, i)) != NULL; i++)
   @{
      if (item->type == MENU_SUBMENU) @{
	      /* This field is submenu. You might call here
	         function to construct submenu. item->shortname contains
		 name for submenu */
      @}
      /* add menu field here.

         You might check flags here:
         item->flags&MENUFLAG_CHECKBOX
	   field have beckbox
         item->flags&MENUFLAG_RADIO
	   field is part of radio button group. In current implementation
	   there is one radio button group per menu.

	 in both cases you might call: menu_enabled(uih, item) to see
	 if item is checked or not.

         item->name contains field's text

	 item->key contains hotkey (one letter string in current
	 implementation)
   @}
@end example
Once field is selected, call function @code{ui_menuactivate(item, NULL)} where
@code{item} is pointer to @code{menuitem} record of selected field.

Function @code{enabledisable} is called when checkbox or radiobutton state is
changed. The @code{name} parameter match to @code{item->shortname} of changed field.
So you need to browse all created menus, compare @code{item->shortname} and in
case it match, call @code{menu_enabled} to obtain new state. For radiobuttons
only enable events are noticed. Your code is expected to automatically disable
all other radiobuttons in the same submenu.

function @code{menu} works in similar way to @code{setrootmenu} but displays
popup menu.

Function @code{dialog} is called for dialogs. The function should look like:
@example
menuitem *item = menu_findcommand(name);
menudialog *dialog = menu_getdialog(uih, item);
int i;
for(i=0; dialog[i].question; i++)
@{
   /* Construct dialog, where left side contains labels with
    dialog[i].question. Right side contains input entities based on the
    dialog[i].type. Dialog[i].type is one of the following:

    DIALOG_INT: integer value input. The default value is: dialog[i].defint
    DIALOG_FLOAT: floating point input value (long double, where availble
    exact). Default value is dialog: dialog[i].deffloat
    DIALOG_COORD: complex value floating point input (two floats), default
    values are dialog[i].deffloat and dialog[i].deffloat2
    DIALOG_STRING: string input. default value is dialog[i].defstr
    DIALOG_IFILE: input file
    DIALOG_OFILE: output file
         default mask is dialog[i].defstr
    DIALOG_CHOICE: choice between various strings.
         retype dialog[i].defstr to char ** to get pointer to NULL terminated
	 array of the choices.
@}
@end example
Once dialog is filled by user, gui_driver is expected to allocate array
of union @code{dialogparam}
@code{dialogparam}:
@example
dialogparam *p = calloc (sizeof (*p), nitems);
@end example
fill selected values. @code{p[i].dint} is used to pass integer value, or
number of DIALOG_CHOICE selection, @code{p[i].number} is used for floating
point number, @code{p[i].dstring} for strings and filenames,
@code{p[i].dcoord[0]} and @code{p[i].dcoord[1]} for complex values.

The string values are expected to be in separate malloced chunks. Once array
is filled, call @code{ui_menuactivate(item, p)}.

The function @code{help} is used to display help about given topic.
To implement it you might eighter convert XaoS help file to some native
format, or use xshl library to render help page for you. To render
xshl page use:
@example
#include <xshl.h>
xshl_line *lines;
int getwidth (void *data, int flags, char *text)
@{
	return width of text with given flags
	flags is mask of the following:
         XSHL_BIG - large text
         XSHL_EMPH - emphatized text
         XSHL_MONOSPACE - monospaced text (typewriter)
         XSHL_LINK - line (should be underlined or so)
         XSHL_WHITE 
         XSHL_RED 
         XSHL_BLACK - color of text (not very meaningfull here)
         XSHL_RIGHTALIGN 
         XSHL_CENTERALIGN - alignment of the text

@}
lines = help_make (name, getwidth, textheight, largetextheight);
if (lines == NULL)
  lines = help_make ("main", getwidth, textheight, largetextheight);

@end example
Now you might use @code{lines} to draw the help. It is pointer to the
arraw of structures:
@example
struct xshl_line @{
  int y;
  struct xshl_item *first;
@};
@end example
@code{y} is possition of the line from beggining of text and first
is pointer to the blocks of texts on the line. Last line contains NULL pointer
in the first section.

@code{first} is linked list of the structures:
@example
struct xshl_item @{
  struct xshl_context c;
  char *text;
  int x;
  int width;
  struct xshl_item *next;
@};
@end example

you might draw text @code{text} on the possition @code{x} (and @code{y} from
the line record) using style described by @code{xshl_context}:
@example
struct xshl_context @{
	  int flags;
	  char *linktext;
@};
@end example
@code{flags} have same meaning as in @code{getwidth} section. @code{linktext}
is name of the next help page in case field have XSHL_LINK atribute.

As an example of @code{gui_driver} see win32 driver code.




@node eui, ui-helper ,gui-driver ,Top
@chapter Writting an external user interface

This part describes, how to make an external user interface---it is the
separate program, which makes an window with all menus and dialogs. It uses
XaoS engine for calculating the fractal as separate process. This design brings
many advantages---the external GUI implementation should have an ``native look''
for given platform and should contain many extensions, such as multiple
windows etc. Also all calculation are done in the multitasking and user
interface is usable even when engine is busy.

The X window provides a way, when program draws into other's
window---``master'' program creates window and sub-window, where he wants to
have fractal, then calls engine with @code{-windowid} @var{number_of_window}
parameters. It instead of creating new window uses specified window. Most
famous example of such cooperation is probably ghostscript/ghostview.

Other windowed environments probably provides similar way for cooperation. At
others it should be implemented using shared memory, so it should work at most
platforms, I expect.

Of course, you might also design UI as separate button box in another window,
like most of animation players, or Imagemagick have. In fact external GUI
should be very similar to Imagemagick style.

@section basic concept

The UI implementation has function to disable it's GUI functions.
Because of the function registry, all it's menus and dialogs are described in
the fairly simple database. This database is mapped also to the scripting
language similar to scheme. So the external UI implementation just translate
the actions into this scripting language and sends it trough pipe.

This commands should be created automatically from the database, as well as
menus and dialogs, so UI don't need to have special code for various XaoS
features. At the beginning it should use XaoS' command @code{(print_menus)} to
force him to send information about database, then build menus using this
information.

For this you need just some equivalent to UNIX pipes, so again I expect it is
doable at most platforms.

@section starting XaoS as slave process

One of the first thinks, engine needs to do is to initialize XaoS in right
mode to work as slave process. For this you need to do several thinks:


@itemize @bullet
@item Open the pipe
@item Disable builtin GUI
@item Read menu hierarchy (this is optional---GUI can also have all menus coded
into it. But it is not recommended, since it will make problems with future
adding new features)
@end itemize

Opening pipe is done via @code{-pipe} option. It takes one parameter, which is
name of FIFO you want use. If you specify ``@code{-}'', XaoS will read input
from stdin.

To disable XaoS GUI use option @code{-nogui}. This will disable all menus,
dialogs and help text.

To read menu hiearchy just add @code{-print_menus} parameter and then parse
XaoS's output. This will print the whole hierarchy. In case you are building
menus at the time, they are selected, you might prefer usage of the command
@code{print_menu}. It prints just one menu without it's sub-menus, so it's
output should be directly used for building it. It takes one string parameter,
which is name of menu you want to print. To print root menu use @code{"root"}.
Option should look like this: @code{-print_menu root}.

Under X Window you need also specify the @code{-windowid}. Also the
@code{-shared} is quite recommended. Otherwise in pseudocolor visuals XaoS will
create it's own colormap, wich will most probably collide with UI's colormap
and XaoS or UI will have false colors. If you have any idea, how to avoid
this, let me know.

You might also let user to specify some extra parameters from the command
line. You should simple add the to the end of command line. The @code{-nogui} and
@code{-print_menus} commands must be first for the simple reason: XaoS parses
it's command line in the early initialization stages. Some commands (like
@code{-print_menus}) should be processed at this time, while others (like
@code{-loadpos} needs to have working engine. This commands are queued and
processed later, once engine is  initialized. In case some such
command is before @code{-print_menus} XaoS will decide to keep same order of
commands, so it will queue @code{-print_menus} too. This will case, that menus
will be printed much later and startup will be slower.

So the proper calling sequence for the user interface under X should look like:


@example
xaos -nogui -print_menus -windowid <id> -share -pipe - @var{[other options]}
@end example

@section Parsing the menu structure

The structure is printed menu by menu. Each menu contains an header, some
entries and @code{endmenu}. Whole listing from @code{print_menus} is
terminated by @code{endmenus}.

The header starts with @code{menu} and then contains an identifier of menu
and full name. Such as:

@example
menu "fractal" "Fractal"
@end example

Then each entry has its own line. It starts by type, which should be
@code{submenu} or @code{menuentry}.

@code{submenu} has similar format to header---fullname of menu and identifier.

@code{menuentry} adds next few fields. It has an type of entry, which should be
@code{normal}, @code{radio} or @code{checkbox}. @code{radio} and
@code{checkbox} are followed by @code{on} or @code{off} specifying whether it
is enabled or disabled. The radio-buttons don't have explicit information about
groups they belongs to. For now I just expect, that each menu contains just
one such group, so it is clear.

Then set of flags should follow. Currently two flags are defined.
@code{dialog}, wich specifies, that function has dialog, and
@code{dialogatdisable}. By default, dialog for check-boxed functions are
displayed just in case they are enabled. The second flag reverses this
behaviour. It is now used for @code{mandlebrot} function, which behaves in this
style. When you disable it, user is prompted for the Julia seed.

So specification should look like this:

@example
menu fractal "Fractal"
submenu "formulae" "mformula"
submenu "Incoloring mode" "mincoloring"
submenu "Outcoloring mode" "moutcoloring"
submenu "Plane" "mplane"
submenu "Palette" "palette"
menuentry "Mandelbrot mode" "uimandelbrot" checkbox off dialogatdisable dialog
menuentry "Perturbation" "uiperturbation" checkbox off dialog
menuentry "View" "uiview" normal dialog
menuentry "Reset to defaults" "initstate" normal
endmenu
@end example

@section Activating functions and dialogs

Once the menu structure is built and user selects some item, it should be
activated. It is done by simple command: @code{(@var{name})}. Once
``@code{)}'' is sent, command is executed by XaoS.

Check-boxed functions has one extra parameter---@code{#t} to enable them and
@code{#f} to disable. So if you want enable item @code{autopilot} send:
@code{autopilot #t}

Radio-buttons don't have any such special parameter---because disabling
radio-button is nonsense.

In case, item has flag dialog enabled, engine expects that UI will
make dialog first, ask user of values and then call function with parameters.
UI needs first to know, what parameters function expect. It is done by sending
command @code{(print_dialog "@var{name}")}.
XaoS replies with dialog specification very similar to menu specification.

It has header @code{dialog} followed by the name of function. Then one dialog
entry per line is sent. it is started by @code{dialogentry} followed by
question UI should display. The is type, which should be one of the following:
@table @code
@item integer
Integer number such as @code{123}
@item float
Floating point number such as @code{123.123}
@item string
String such as @code{"ahoj"}
@item keyword
String such as @code{'ahoj}. The keywords are mostly similar to string, except
they can not contain space. They are used for example for specifying formula
type. Strings are used for printing texts etc.
@item inputfile
@item outputfile
Here UI should display file selection dialogs. With @code{outputfile} it is
also good idea to check, whether file exist and in this case make some
overwriting dialog too.
@item onoff
Boolean value (@code{#f}, or @code{#t})
@item complex
Complex value---two floating point numbers such as @code{123.123 123.123}
@item choice
Choice between some keywords. Those keywords are send after @code{choice} in
enclosed the @code{@{} @code{@}}. 
@end table
Last information at the line is the default value in the same format as
examples above. For files, the default value is in format @code{"@var{[prefix]}*@var{[extension]}"}.

Some examples:

@example
customdialog "uiview"
dialogentry "center:" complex 0.000000 0.000000
dialogentry "Radius:" float 0.000000
dialogentry "Angle:" float 0.000000
enddialog

dialog "load"
dialogentry "Filename:" inputfile "fract*.xpf"
enddialog

customdialog "color"
dialogentry "Color" choice @{white black red @}white
enddialog

@end example

To activate function, send command which contain function name, possible @code{#t}/@code{#f}
in check-boxes and parameters in the same order as in dialog, same format as in
examples, separated by the space. Such as:

@example
(uiview 0 0 0.5 0)
(load "text.xpf")
(color 'white)
@end example

@section Synchronization

In some cases, XaoS can change radio-box and check-box values. (like when user
pressed a key, or loaded some file). So all changes are sent to GUI, wich
should inform about this. They are sent to standard output in following
format:

@example
checkbox "name" on/off
radio "name" on/off
@end example

So your GUI should parse this and change it's menus when necessary.

Also XaoS's menus can contain more distinct trees. In some cases (like when
animation replay is active) root of menu structure should change. The XaoS
sends command:

@example
root "name"
@end example

Also user can press keys, which normally displayed menus, dialogs or help. Then
XaoS sends commands:

@example
menu "name"
dialog "name"
help "topic"
@end example

All this commands should be taken into account by GUI, or should be ignored.

@section help

XaoS's help is in the simple hypertext language. In order to simplify it's
parsing I've made an xshl and help libraries. So making of help window should
be quite easy. Just call help function:
@deftypefn Function struct xshl_line *help_make (char *@var{command}, int @var{getwidth} (void *, int @var{flags}, char *@var{text}), int @var{width}, int @var{smallheight}, int @var{bigheight});
@end deftypefn
and you will receive of listings of text with positions, where to print into
window.

@code{command} parameter is topic of help. @code{getwidth} function is
function, wich returns width of given text. @code{width} is width of window,
@code{smallheight} is height of small font and @code{bigheight} is height of
big font.

Please ask me for more details if necessary.

And thats all. Good luck with coding.

@node ui-helper, xthreads ,eui ,Top
@chapter UI-helper library

UI helper library takes care to all XaoS' engine functions and features and
gives the higher level API, which is quite easy to understand. If you want to
write completely new user interface (replacement for the ugly interface---not
just new bindings for native menus or external user interfaces) or you want to
use XaoS engine in your program as an library, you will probably want to use
this library.

It's API has many calls and features. This section gives just brief overview
of it's calls. Please ask me about details.

@section initialization

To initialize ui helper library, you need to prepare an palette and image.
Palette is created using palette library calls @code{createpalette}. Creating
truecolor palette should look like this:

@example
  struct palette *pal = createpalette (0, 0, TRUECOLOR, 0, 0, NULL,
                                       NULL, NULL, NULL);
@end example

For details about creating palettes see @code{ui.c} or ask me.

To create image call:

@example
  struct *image img = create_image_mem (width, height, 2, pal,
                                        pixelwidth, pixelheight);
@end example

This creates image in the memory. If you want to create it in your own
buffers, you might use @code{create_image_cont} or @code{create_image} calls.
Again see @code{ui.c}.

Then it is time to fire up main library:

@example
  struct uih_context *uih = uih_mkcontext (0, img, passfunc,
                                           NULL, NULL);
@end example

The @code{passfunc} is called when engine is calculating. It might process
events and display process information. It should look like this:

@example
static int
ui_passfunc (struct uih_context *c, int display, char *text, float percent)
@{
  /*process events */
  if (uih->display)
    @{
      uih_drawwindows (uih);
      /*display */
    @}
  if (display)
    @{
      if (percent)
	sprintf (str, "%s %3.2f%%        ", text, (double) percent);
      else
	sprintf (str, "%s          ", text);
      /*display it */
    @}
@}
@end example
It might set @code{uih->interrupt}, if it wants to interrupt current
calculation.

You also might load the catalog file in order to make tutorials working:

@example
  uih_loadcatalog (uih, "english");
@end example

Since this ui_helper library is fully functional and you might enter the main
loop.

@section main loop
UI helper library does an timing primitives. So it expect an standard form of
the main loop. It asks the program to display changed image when necessary.
Library also use timerlib for it's timing. So read section about this
library, since you might use it for your purposes too.

Main loop should look like this:

@example
while (1)
  @{
    if (uih->display)
      @{
	uih_prepare_image (uih);
	uih_drawwindows(uih);
	/*display current image buffer*/
      @}
    uih_update (uih, mousex, mousey, buttons);
    if ((time = tl_process_group (syncgroup, NULL)) != -1 &&
	    !uih->inanimation) @{
	    /*relax given time in usec - wait of events etc..*/
    @}
    /*and repeat*/
  @}
@end example

@section calling functions

UI helper library has many functions declared in @code{ui_helper.h} for
various actions. There is too much of them to describe, but their names are
quite informative, so I hope you will not have problems.

You might also use XaoS function registry, which does all this stuff for you.
You will just draw menus and dialogs based at this registry and automatically
all features will be available. So if you are writing an ordinary user
interface, this is the preffered way.

Note that @code{ui_helper} library is not reentrant, so you can't call most of this
function from the @code{passfunc}. If you are using registry, activating
function handles this automatically and queues functions when necessary. 
To process them you need to flush queue in the main loop as follows:

@example
static void
processbuffer (void)
@{
  menuitem *item;
  dialogparam *d;
  if (uih->incalculation)
    return;
  while ((item = menu_delqueue (&d)) != NULL)
    @{
      menu_menuactivate (item, d);
    @}
@}
@end example

@section closing library

This is done using: 

@example
  uih_freecontext (uih);
@end example

One implementation of user interface at the top is ugly interface. See
dirrectory @code{src/ui}. Another, much simpler is @code{render.c}, which does
animation rendering.

@node xthreads, filters ,ui-helper ,Top
@chapter XaoS thread library

This description should be useful for those, who want to port XaoS
into multiprocessor platforms and those, who want to implement some
filter or other relatively computational expensive code. Note that thread
library should be mapped into nothread calls, in case host does not allows
multi-threading or it is not SMP architecture (since this library is
used only to distribute calculation into other CPUs)

XaoS thread library is simple map of few functions required by XaoS
to system library for threads.

It has following variables:

@deffn Variable ethreads
This is set to 1 in case that threads are enabled
@end deffn

@deffn Variable nthreads
Number of threads
@end deffn

It and following calls:

@deftypefn Function {void} xth_init (int @var{threads})
This function initializes threading library (starts threads, sets
@var{ethread} to 1 and @var{nthreads} to n. @var{Threads} parameter should be
set to 0---auto-detection or number of threads users wants. In case threads
is set to 1, threading library is disabled and following functions are
mapped into those nothread_ equivalents defined in @code{xthread.h}.

Note that threads are not identical---there is main thread (one that called
xth_init) that communicates with drivers, controls calculation etc. and other
tasks that are waiting to orders from main task. They also can't use functions
from xthread library.
@end deftypefn

@deftypefn Function {void} xth_uninit (void)
This function UN-initialize thread library---kills child threads, sets
@var{ethread} to 0 and @var{nthreads} to 1. 
@end deftypefn

@deftypefn Function {void} xth_function (xfunction *@var{function}, void *data, int @var{range})
This function is used in case, engine wants to perform some operation at image
in parael. It is expected to wait until all threads are ready and start @var{function} 
at all threads including control one with following parameters: @var{data}---this
parameter is same as
@var{data} passed to xth_function, @var{taskinfo}---pointer to structure
taskinfo, that is platform depended (defined in @code{xthread.h}) but must
have at least field @code{n}, that holds number of thread (control thread has
0 and other numbers in range 1 -- @var{nthreads}). Next two parameters is
range of image, function is expected to do action. Xth_function is expected to
divided @var{range} into @var{nthreads} equal pieces and pass always start of
piece and start of next piece (@var{range} in case of last one). Function does
not wait for other threads at the end and returns immediately to main thread
after @var{function} returns.

This function is called approx. 5--10 times per frame
@end deftypefn

@deftypefn Function {void} xth_sync (void)
This functions waits until all threads are ready for next order from main
task. 

This function is called approx 5--10 times per frame
@end deftypefn

@deftypefn Function {void} xth_bgjob (xfunction *@var{function}, void *@var{data})
This function is expected to behave as follows: look if there is any thread
waiting for orders, if so, ask him to call @var{function} with similar
conventions as in xth_function except that range parameters are set to 0.
Otherwise it starts function in normally (at foreground).

This function is called once per frame.
@end deftypefn

@deftypefn Function {void} xth_nthread (struct taskinfo *@var{s})
This function should be used to determine number of current thread. Do not use
@code{taskinfo->n} instead since in case threads are disabled, it should be
defined to 0 and that allows optimizer to perform better optimizations.
This function should be called by all threads.
@end deftypefn

@deftypefn Function {void} xth_lock (int @var{n})
@end deftypefn
@deftypefn Function {void} xth_unlock (int @var{n})
Lock/unlock lock number @var{n}. At least @code{MAXSEMAPHORS} locks must be
available.
@findex MAXSEMAPHORS

Note that locks are used always for very short fragments of code so they
needs to be fast. So spin-locks are maybe better than Dijskra semaphores.
Untested. They are called once per calculated line/row during zoom and
once per approx 10 pixels during calculation of new image.
@end deftypefn

@findex MAXCONDS
@deftypefn Function {void} xth_sleep (int @var{n}, int @var{l})
It is expected to atomically unlock lock @var{l} and sleep in queue @var{n}.
At least @code{MAXCONDS} queues must be available.
After it is waked up, lock @var{l} again. This mechanism is used by
calculation of new image algorithm, but it is designed to minimize its calls,
so I expect they should be called once or twice.
@end deftypefn

@deftypefn Function {void} xth_wakeup (int @var{n})
Wake up some thread from queue @var{n}. Lock used by
sleep calls is locked in this cases. Function should also wake up all threads
if such operation is not supported by host API. With luck, this function
should not be called at all. It should be called by new image calculation
routines in case queue is empty. This happens in case of 50 threads but
happens rarely at two or eight threads according to my tests.
@end deftypefn

@deftypefn Function {void} xth_wakeall (int @var{n})
Similar to wakeup but wake up all threads.
@end deftypefn


@node filters, algorithm ,xthreads ,Top
@chapter Filters

This is a brief description of filter system used internally by XaoS.
Filters in XaoS provides an object oriented interface to every part
of XaoS engine. Main filters are: User interface implemented in ui_helper.c
and zooming engine implemented in zoom.c. Filters are connected into
an queue---at the beginning there is just two filters here(zoom and ui)
but later additional filters should be inserted into the middle of queue
like an stereo-gram generation etc. The queue supports operations like
remove filter, add filter and initialize.

In the calculation every filter should use data calculated by filter lower
in the queue. Data are stored into image. So for example stereo-gram filter
should use fractal generated by zooming engine and create an stereo-gram.

This makes XaoS's code more flexible and makes easy future enhancements
like different zooming engine, image rotation, other special effects,
plug-ins and some other funny stuff since interface of each such part
is well defined and each filter has quite good control over his child.
So stereo-gram filter should change palette, force zooming engine to change
depth, width and height of calculated image to fit his needs and so on.

This document describes mainly creating of filter like stereo-gram generator
i.e. filter placed into middle of queue since I don't expect there will be
many people creating ``terminal'' filters (zooming engines/user interface
layer) note that different user interface is possible since user interface
layer is not the real user interface just set of high level functions that
should be called by main application like set_view. So in case you want
to use XaoS as an calculation engine in your program this document is probably
not for you.

Each filter is defined by filter_action structures as follows:
@findex filteraction
@example
struct filteraction @{
  char *name;
  char *shortname;
  int flags;
  struct filter *(*getinstance)(struct filteraction *a);
  void (*destroyinstance)(struct filter *f);
  int (*doit)(struct filter *f,int flags,int time);
  int (*requirement)(struct filter *f,struct requirements *r);
  int (*initialize)(struct filter *f,struct initdata *i);
  void (*convertup)(struct filter *f,int *x,int *y);
  void (*convertdown)(struct filter *f,int *x,int *y);
  void (*removefilter)(struct filter *f);
@};
@end example
This structure describes static filter's parameters (like its name) and
basic set of methods required for communication with resto of XaoS.
The name field describes filter's name like ``An random dot stereo-gram
generator''. Name is displayed by ugly interface in filter's menu. So
it is expected to be descriptive and shorter than 30 characters. The short
name is one word long name for filter like ``stereogram''. This name is
used by save files, possibly by command line parameters. Simply everywhere
where user should need to write it and writing long descriptive name should
be just wasting of time and disk space.

Flags field is kept for future enhancements and is expected to be 0 for now.

@section Creating / destroying of instance

Functions getinstance and destroyinstance are equivalents to constructor and destructor
in OOP. Getinstance is expected to create and fill following structure:

@findex filter
@example
struct filter @{
  struct filter *next,*previous;
  struct queue *queue;
  struct filteraction *action;
  struct image *image,*childimage;
  struct requirements req;
  struct fractal_context *fractalc;
  void *data;
  char *name;
  int flags;
  void (*wait_function) (struct filter *f);
  /*stuff for wait_function*/
  int pos,max,incalculation,readyforinterrupt,interrupt;
  char *pass;
@};
@end example
Altrought this structure seems to be long and complex, most of fields are
unused at this time and rest of them are filled automatically by function:

@deftypefn Function {struct filter *} createfilter (struct filteraction *@var{fa});

That should be used to create instance. Only possibly interesting field
is data. It's pointer reserved for filter's internal use. So it should
be pointer to filter's internal variables if required. Following is
example implementation of get-instance with allocating of such additional
structure. In case nothing similar is required you should use directly
createfilter at getinstance's place.
@end deftypefn

@findex getinstance
@example
static struct filter *getinstance(struct filteraction *a)
@{
      struct filter *f = createfilter(a);    /*create filter structure*/
      struct stereogramdata *i=calloc(sizeof(*i),1);
                                             /*allocate internal variables*/
      /*initialize your variables here*/
      f->data=i;                             /*add pointer to internal data*/
      return (f);
@}
@end example

The destroyinstance is expected to free memory used by filter structure and
all internal data of filter. To free filter structure use normal free(filter);
So implementation of such function should look like:
@example
static void destroyinstance(struct filter *f)
@{
     destroyinheredimage(f);
     free(f->data);
     free(f);
@}
@end example
The meaning of destroyinheredimage will be described later.


@section Initialization

During initialization phaste each filter says to his parent what kind
of images it supports (this should depend on images supported by his child),
parent chooses best supported image format for his purposes and gives 
it to the child. Initialization is done in two pases.

First pass start by lowest filter in the queue and each filter passes to
his parents requirement structure.

Second pass starts by the highest filter and each filter passes to child
an image and some other stuff. Then calculation should begin.

Queue needs to be reinitialized after creating, resizing, adding/removing
of filter and similar operations.

First pass is implemented using require function. This function is expected
to take care at child's requirements it received as parameter, fill
requirements structure and call require function of his parent filter.
@findex requirements
@example
struct requirements @{
  int nimages;
  int supportedmask;
  int flags;
@};
@end example
The nimages field should be set to 1 or 2. In case it is 2, parent filter
must pass image with two buffers. Note that in case it is 1, parent should
pass image with two buffers too.

Supported mask is mask of supported image types by filter. Image types
are following:
@findex C256
@findex FIXEDCOLOR
@findex GRAYSCALE
@findex TRUECOLOR
@findex TRUECOLOR24
@findex TRUECOLOR32
@table @code
@item C256
  An normal 8bpp image with palette
@item TRUECOLOR24
  An 24bpp truecolor image with 8bits for each color.
@item TRUECOLOR16
  An 16bpp truecolor image
@item TRUECOLOR
  An 32bpp truecolor image with 8bits for each color.
@item LARGEITER
  An 16bpp image but w/o colors. It is expected to hold number of iterations
  it should be also tought as 16bpp grayscale image
@item SMALLITER
  Similar to @code{LARGEITER} but 8bpp
@end table

@findex MASK1BPP
In case you don't worry about palettes, allocations of colors and you do just
some operation with bitmap, so you worry just about depth of image you should
use mask of following: @code{MASK1BPP} for 8 bit images, @code{MASK2BPP} for 16bit and so on.

The latest field of requirements structure is flags. It mask from following
constants:

@table @code
@item IMAGEDATA
  in case your filter requires data from previous frame untouched. In case
  this is not set, filters should reuse your image and change it. But some
  filters like and motion blur or zooming engine requires data from previous
  frame to construct new, so this flag should be set
@end table
there is no more flags supported at the moment. Function require should also
save child's require structure into filter->req for later use by initialize
pass. So you should look like:
@example
static int requirement(struct filter *f,struct requirements *r)
@{
  f->req=*r;    /*Save an child's requirements*/
  r->nimages=1; /*Just one image is required*/
  r->flags&=~IMAGEDATA;/*unset the imagedata field*/
  r->supportedmask=C256|TRUECOLOR|HICOLOR|REALCOLOR;
                /*mask of all supported image types*/
  return (f->next->action->requirement(f->next, r));
                /*call parent*/
@}
@end example
Next pass is main initialization. It goes in opposite order(from parent
to child) and child's infers some stuff from parent like images etc...
The initialize structure receives an initdata structure:
@findex initdata
@example
struct initdata @{
  void (*wait_function) (struct filter *f);
  struct image *image;
  struct fractal_context *fractalc;
  int flags;
@};
@end example
an wait_function is function called by filter during calculation that
lets the parent filters(usually user interface layer) to inform user
how calculation continues. Image is an image expected to be filled
by image in calculation phaste. Fractalc is pointer to structure that
will contain information about fractal during calculation(like formula
type etc...) Flags is mask of following constants:
@table @code
@item DATALOST
 this is set in case, that data in image was lost(image was cleared or
 resized or freshly allocated). Filters that uses data from previous frames
 should take care to this flag. Zooming engine for example recalculates
 whole image since pixels from previous frame was lost.
 Note that data should be lost also in case, filter receives different
 image that in previous initialization since some filter behind was
 removed.
@end table
An inhering process is done using function:

@deftypefn Function void inhermisc (struct filter *@var{f},struct initdata *@var{i});

This function sets fields in filter structure like as fractalc or wait_func.
Inhering of image is quite complex, since new image needs to be prepared
for child. In order to save memory it is highly recommended to use same
image or at least same memory for data when passing to child. But this
is not allays possible. Following function implements heuristic to do this:
@end deftypefn
@deftypefn Function int inherimage (struct filter *@var{f},struct initdata *@var{data}, int @var{flags}, int @var{width}, int @var{height}, struct palette *@var{palette}, float @var{pixelwidth}, float @var{pixelheight}) 
You should call this function in your initialize pass. It fills image and
childimage in filter structure, prepares initdata for child and creates
image for child. Note that it should fail in some cases and return 0. In
this case filter is expected to interrupt initialization and return 0 too.

An @var{flags} parameter is mask of following constants:
@table @code
@item IMAGEDATA
  in case your filter requires data from previous frame
@item TOUCHDATA
  In case your filter touches data in output image. This is very usual but
  there is some filters (like interlace or subwindow that don't)
@item NEWIMAGE
  Set in case your filter can not deal with shared images (images that have
  input data in same memory are as output)
@end table
@var{Width} and @var{height} should be set to 0 in case you want same width/height as
in parent image or width and height of image you want to pass to child.
@var{Palette} is palette of image you want to pass. Set to @code{NULL} if palette should
be inhered from parent's image (usual).
@var{Pixelwidth} and @var{pixelheight} specifies physical size of pixel in centimeters.
If set to 0 they are inhered from parent's image.
@end deftypefn

In case you use inherimage mechanism you also must call destroyinheredimage
in destroyinstance function and updateinheredimage at the beginning of calculate
function.

Example implementation:
@example
static int initialize(struct filter *f,struct initdata *i)
@{struct stereogramdata *s=f->data;
  inhermisc(f,i);
  if(!inherimage(f,i,TOUCHIMAGE,0,0,NULL,0,0) return 0;
  /*initialize here*/
  return(f->previous->action->initialize(f->previous,i));
@}
@end example
Also note that fractal context hold pointer to fractal palette. In case
You don't change image palette everything is OK. But in case child's image
differs from parents image, there should be two behaviors---fractal's palette
is child one (this should be common for example in conversion filters (
8bpp to truecolor etc)) or fractal's palette is parent's one (like in
edge detection filter). By default fractal's palette is kept to parent's one.
This should be changed by setfractalpalette call. It has two parameters---filter structure and palette. When you pass as palette child's palette,
fractal's palette will be changed to child. In case you pass NULL. Changing
of palette will be disabled (like in motion blur filter in 8bpp mode).
Note that this is changed just in case you still have access to fractal palette.
Some parent should redirect palette before. Than this function does nothing.


@section Caluclation

Main calculation is done using doit function. It is expected to call
child's calculation function when required and apply filter at output.
It receives flags. Only flag in @code{INTERRUPTIBLE} for now. It is mainly
for zooming engine so I do not describe it here. But filter is expected to
pass this flag to child. Next parameter is time in milliseconds that
expired since last doit call. It should be used to calculate speed
of animation.

Calculation loops returns flags. Flags is mask from following constants:
@findex ANIMATION
@findex CHANGED
@findex INEXACT
@table @code
@item ANIMATION
 in case filter performs some animation and expect that calculation will be
 called again soon
@item CHANGED
 in case something changed in output image (usual)
@item INEXACT
 This is enabled by zooming engine in @code{INTERRUPTIBLE} mode in case that time
 exceeded.
@end table

An doit function changes image. Image structure contains following fields
significant for you:
@findex image
@table @code
@item bytesperpixel
  number of bytes per pixel (image depth)
@item palette
  palette of image.
@item currlines
  array of pointers to beginnings of every scanline of image
@item oldlines
  array of pointers like currlines but for previous image in case
  doublebuffering is enabled
@item nimages
  set to 2 in case doublebuffering is active
@item flipimage
  pointer to function that flips oldlines and currlines.
@end table

palette structure contains following significant fields:

@table @code
@item type
 type of palette/image (@code{C256}, @code{TRUECOLOR} etc...)
@item size
 number of allocated entries
@item pixels
 array of allocated entries. Conversion table from number of iteration
 to pixel value.
@item rgb
 Rgb values for pixels (@code{NULL} for @code{TRUECOLOR}, @code{HICOLOR} and similiar types)
@end table

To make easier writing calculation loops for different depths @code{pixel8_t},
@code{pixel16_t} and @code{pixel32_t} are predefined. You also can use include system
as in edge detection filter, that lets you write calculation loops just
once and use cpixel_t and it will be compiled for every bitmap depth.
See edge detection filter (engine/edge.c and engine/edged.c) for
implementation details.


@section Conversion

Convertup and convertdown functions are used for converting screen coordinates
to position in fractal and back. Convertup is function that receives
coordinates in child's image and is expected to convert them into coordinates
in parents image and call parent's convertup function.

Convertdown is reversed(from parent to child).

In case coordinates respond 1:1 you should use convertupgeneric and
convertdowngeneric. In other case implementation should look like:

@example
static void convertup(struct filter *f,int *x,int *y)
@{
    *y*=2;
    *x*=2;
    if(f->next!=NULL) f->next->action->convertup(f->next,x,y);
@}
static void convertdown(struct filter *f,int *x,int *y)
@{
    *y/=2;
    *x/=2;
    if(f->previous!=NULL) f->previous->action->convertdown(f->previous,x,y);
@}
@end example

@section Removing of filter

Before filter is removed from queue, removefilter function is called.
It is expected to clean up thinks filter changed. Should be NULL
in most cases.

@section Registering of filter

Once filteraction structure is filled, filter is done and you should try
to enable it. To enable it in user interface you need to edit ui/ui_helper.c,
add filter into uih_filters structure and increase uih_nfilters.
Note that order of filters in uih_filter is significant, since same order
is kept in filter queue, so you should specify if you want to be called
before/after filter xy.

Then it is high time to start experimenting.

Good luck!
@node algorithm, timerlib, filters ,Top
@chapter Algorithm description
The main idea behind XaoS is that it is not required to calculate the
whole image every frame. Most pixels are already calculated in the
previous frames. You usually don't have exactly the pixels you want,
but all within a range lower than a step between pixels are
acceptable. That is why the image flicker a bit and why points do not
blink randomly as in recalculated animations.
   
   This document describes some of the most important algorithms in XaoS
   @itemize @bullet
     @item Saving Previous Pixels
     @item Approximation Algorithm
     @item Moving Pixels to New Positions
     @item Calculating New Pixels
     @item Symmetry
     @item Calculation of Mandelbrot Set
     @item Dynamic Resolution
     @item Autopilot
    @end itemize   
   
@section Saving Previous Pixels

Ideally, all recalculated points should be saved and used for
building successive frames. I could not figure out a practical way to
implement this. To save all frames for half an hour would require 24
Mb of memory, and searching the saved frames would be more
computationally expensive than recalculating an entirely new frame.

One way was later used by program Frang. It remembers all pixels as
x,y and value fields and when it builds new image, it draws all pixels
to it and then browses image and fills it by new pixels. Possibly some
rle cache should be used for calculated pixels. Frang actually uses algorithm,
that takes away pixels out of screen, so it behaves exactly in same way
as algorihm described here. At the other hand, this method seems to require
much more memory than XaoS algorithm and drawing pixels/browsing image cost
quite a lot, so algorithm described here seems to be faster. Since it never
requires examining of whole image and new image is constructed using
block move operations.

For this reason only the last generated frame is used as reference.
This way the memory requirements are proportional to xsize * ysize. It
can be shown that this method is only about 2-5% slower during
zooming. Of course unzooming back to once browsed areas is much slower.
   
Because only the previous frame is used, another optimization can be
performed: Imaginary and real parts of the calculated image are not
precise since they are the result of successive iterations of same
algorithm. In order to prevent errors from being distributed to the
following frames their exact coordinates need to be known.
Fortunately, it isn't necessary to save their values since it is
known that all real components in a row and all imaginary components
in a column are equal. Thus, the only things that must be saved are
the real components for every row and the imaginary components for
every column.
   
This allows for a substantial speed-up in approximation because the
calculation requires less data. Of course, some rows and columns fall
out of the threshold and new ones need to be calculate to fill in the
gaps in the frame.
   
Obviously, much less work is done. There are only @math{xsize + ysize}
calculations instead of @math{xsize * ysize}. So the main loop in XaoS looks
like this:
   @itemize @bullet
     @item Make approximations for rows
     @item Make approximations for columns
     @item Move old pixels to their new positions
     @item Calculate pixels for which there is no good approximation for
       their row
     @item Calculate pixels for which there is not good approximation for
       their column but there is one for their row
    @end itemize
       
   
@section Approximation Algorithm

  @unnumberedsubsec Introduction to problem
   
You can see that the approximation algorithm is central to the
implementation of XaoS. If the guess is incorrect the image will look
strange, boundaries will not be smooth and the zoom will flicker. On
the other hand, if it adds more new rows or columns than required,
zooming will become much slower. Also, in the instance of doubling
(i.e., using an old row or column more than once) the resolution will
lower. It is important to keep the increasing imaginary and real
components in the correct order. If a row and column of complex
coordinates follows one with higher coordinate values an improved
approximation can be attained by swapping their values.
   
The algorithm needs to be relatively fast. It is only used for @math{xsize + ysize}
values but if its speed is proportional to @math{O(n^2)}, it can be
slower than a whole recalculation of the image. Speeds of @math{O(n)} or @math{O(n * log(n))} are acceptable.
   
  @unnumberedsubsec Some simple algorithms to solve it
  
   
   
Initially, a very simple algorithm was used:
   
  Find the old row/column nearest the row/column that needs to be
  regenerated. If the difference between them is less than one step
  (@math{step = (end - beginning) / resolution}) then use it. Otherwise,
  recalculate a new one.
     
Finding the nearest row/column pair is very simple since it is always
greater or equal to the pair needing to be generated.
   
Surprisingly, this simple algorithm has almost all the problems
described above. Doubling was fixed by lowering the limit to @math{step / 2.}
This cause a considerable slowdown so the limit was returned to step.
Instead, the algorithm was changed to search for only row/column pairs
that are greater than the previous frame's row/column pairs. This is
the algorithm that was used in version 1.0
   
This algorithm still added to many new rows and columns and did not
generate smooth boundaries. For version 1.1 a heuristic was added that
preferred approximating rows/columns with lower values. This way it
did not occupy possible rows/columns for the next approximation. The
result was a speedup by a magnitude of four. In versions 1.1 to 2.0
many improvements were made to the heuristic to give it added
performance. The following example tries to explain how complicated
the problem is (O is the old coordinates and X is the values to be
approximated):
@example
        X1        X2        X3        X4        X5        X6        X7
O1 O2                    O3 O4 O5                   O6 O7 O8
@end example

The normal algorithm will aproximate X1 by O2, X3 by O4 but nothing
more. For the algorithm with threshold step instead of @math{step / 2}:

@example
  O2 to X1
  O3 to X2
  O4 to X3
  O5 to X4
  O6 to X5
  O8 to X6
@end example

But this will fail with X7. The second algorithm which relies on lower
values will do the following:

@example
  O1 to X1
  O3 to X2
  O4 to X3
  O5 to X4
  O6 to X5
  O7 to X6
  O8 to X7
@end example

O1 to X1 is wrong. And there is many and many other situations that
may occur. But you may see that the normal algorithm will calculate 4
new rows/columns but the heuristic saves all of these calculations.
   
  @unnumberedsubsec Current algorithms used
  
   
   
In version 2.1 work on this heuristic was disabled after I discovered
a surprisingly simple algorithm that solves all these problems. First I
decided to define exactly what is best approximation. This should be
done by defining a price for every approximation and choose the
approximation with the lowest price. Prices are defined as such:
   
  Approximating row/column x by y costs @math{dist(x, y) ^ 2}.
     
This prefers two smaller approximation errors before a single larger
error and describes my goal quite well.
   
The cost for adding a new row/column specifies when it is better to do
a bad approximation and when to add a new row/column. I use @math{(4 * step)
* (4 * step)}. This means that the approximation is acceptable when
@math{dist(x, y) < 4 * step}. Otherwise, adding a new row/column costs less.
Now the best approximation is known. All that is required is a fast
algorithm to do this. Surprisingly, this is possible in linear time
using a relatively simple dynamic algorithm. It uses approximations of
@math{length < n} to make a guess at the length of @math{n}. It can start by
approximating one row/column and then again for two, three up to
xsize/ysize rows/columns.
   
The algorithm starts by calculating prices for all possible new
positions for old row/column 1. Because of the pricing there are
maximally 8 new positions. (Other ones must cost more than adding new
row/column). Of course it is possible that there are no new positions.


For calculating the price of approximations for row/column 2 I may use
previous one: Try new position n. Calculate the price and add the best
approximation for the previous (row/column 1) one that uses a new
position lower than n(prohibits doubling or swapping). This should be
one of 8 positions or eventually adding of new one and not using
row/column 1 at all.

The same method can be used for the rest of the rows/columns. At the
end the best price may be found for the last row/column and return by
the way it was calculated. (For this I need the saved ``calculated
using'' values.) At this step the best approximation has been
determined.

To fill the table, @math{9 * n} steps are required and n steps to backtrack
best approximation. The only problem is that this algorithm is still a
little slow (chiefly because of slow memory access on Intel
architectures). -But with some optimizing it works well.

This algorithm is almost perfect except that it occasionally adds new
rows/columns to the wrong locations. It does not prefer to add new
rows/columns into holes. But it does not seem that this is the real
problem. The last optimization made was based upon the face that added
rows/columns do not have the exact real and imaginary components
calculated by (@math{beginning + x * step}) but lies at the average of left
and right neighbors. This makes the boundaries smooth and distributes
coordinates better. It also has the added benefit of making the input
better for future approximations.

Another danger during implementation if this algorithm is that adding new
rows/columns into their ideal positions should cause miss-ordered results,
since some rows/columns should be off more that is distance between them.
To avoid this, I use algorithm that always examine start and end of block
of new rows/columns and linearly interpolates value between them. Special
care needs to be at the blocks that start at the beginning or overs at
the end.

Implementation should be much faster using custom fixedpoint routines---first recalculate values that 0 means start of image and 65536 means end.
Than calculation is much cleaner. Values <0 and >65536 are of screen, 
calculation is independent at scale and many thinks should be
recalculated---like tables for calculating price from distance.
Also dividing main loops into many specialized parts and avoiding
filing unnecessary parts of table helps. So current algorithm in XaoS is about 
5 or 6 times faster than first naive implementation.
   
@section Moving Pixels to New Positions

   
   
Since XaoS is using the approximation algorithm the following table is
filled for every row/column:
   @itemize @bullet
     @item calculate
     @item oldpoint
     @item position
   @end itemize
       
calculate is 1 if the current row/column is new and needs to be
calculated or 0 if no old pixels need to be moved. oldpoint is a
pointer to the old row/column that corresponds to the new one. This
pixel needs to be copied to the new location. position is the real and
imaginary components of the coordinates used for future
approximations. Because almost all points will be moved, the solution
seems to be simple: for every new point look at the row and column
table; copy it if required.

There is the problem that this minimally needs three memory reads for
every pixel (read calculate, oldpoint and index of old point). This is
too slow, so a small optimization is performed. Instead rewriting the
piece of code in assembly, normal memcpy is used to move blocks of
pixels to their new locations. This minimizes the internal loop and
access can be done more quickly since memcpy is usually optimized for
each architecture.

Using the row table, a list of blocks to move for every row is
created. With this new table all the pixels can be moved quickly. This
increased the speed of XaoS about four times and made this function so
fast that it is no longer a problem. (In fact, it takes much less
processing than all other parts of XaoS.)

@section Calculating New Pixels
   
The above optimizations make XaoS very fast, but another 30% increase
in speed is acquired by using a clever method for calculating the new
pixels. Many methods are known for saving calculations during the
generation of fractal images. The most powerful is boundary detection.
It relies on the fact that the Mandelbrot Set is connected with lakes.
You need only one pixel at the boundary, then traverse the whole set
and then fill the solid area inside. This method saves many
calculations but is too complex for adding just one line. Many claim
that it does not introduce any errors, but this is not true. It is
possible for a connected part of the lake to be so small that it is
not visible in smaller resolutions. In this case, boundary detection
misses the whole area. This algorithm is actually used just for
calculating of new images (i.e. at the startup). 

XaoS uses modification of method known as solid guessing. The pixels
at the boundaries of a rectangle are calculated. If they are all the
same you may assume that this rectangle does not does not contain
anything and fill it.

This algorithm is further modified to operate on added lines. For this
it is at least as good as boundary detection and produces more
tangible errors. When adding a single line, the upper and lower line
may be examined for the nearest three pixels. If they are all the same
then it is assumed that 9x9 pixels are the same. This disables all
calculations inside solid areas and calculates as many points as
boundary detection. The only possibility of creating a larger error
with this method as opposed to boundary detection is in the instance
that the shape of the set is so sharp that it does not set any of the
tested points but comes from the right (i.e., uncalculated) location.
This situation is not very common.

Later, rules were added for new rows and columns that crossed each
other. In this instance you can test only four pixels. This situation
is very rare. It is hoped that it does not introduce many errors.

If multiple blocks of new lines need to be calculated there are not
reference pixels to use for solid guessing. Interlacing does the
trick. By calculating the odd lines without any guessing, the guessing
algorithm is now possible for the remaining uncalculated lines. This
simple trick saves about 30% of the calculation of the main Mandelbrot
image.

A similar approximation can also be done for the X coordinate. This
makes it possible to improve solid guessing at even pixels because all
surrounding pixels are available, further reducing errors.

@section Symmetry

   
   
Many fractals are horizontally or vertically symmetrical. This is
implemented in the approximation code. When there is no good
approximation available, try to mirror the opposite side if the line
is available.

This method primarily speeds up the initial image.
   
@section Calculation of the Mandelbrot Set

Internal Mandelbrot calculation loop is unrolled---it calculates
first 8 iterations using normal method and then it expects that number
of iterations will be probably large so it switches into mode, where it
calculates iterations in block of 8 with one bailout test at the end.
When bailout is received, saved values from previous iterations is
restored and last 8 iterations are recalculated slowly to get exact
values. This helps a lot especially at Pentium, where conditionals in
floating point code is slow.

Another stuff is periodicity checking. XaoS has both version of loops---with an without periodicity checks. In most cases it uses nonperiodicity
checking version. Periodicity check version is used just in case, some inside
set pixel has been found during solid guessing paste around. This is done
mainly because periodicity checking version of loop is significantly slower.
   
@section Dynamic Resolution
   
The above optimizations often do not help enough and image calculation
is still too slow. One option was to reduce the framerate, but a
framerate lower than 5 frames per second is unbearable. Another option
is simply to calculate only the details that can be determined within
a time interval.

Rows/columns not calculated are simple approximated by referencing the
nearest other row/column. The result is an image with larger pixels.
One problem is the fact that the order of calculating the rows/columns
is significant. Previous versions of XaoS simply calculated all rows
from top to bottom and then columns from left to right. Using the
dynamic resolution code with this algorithm would result in distorted
images. This was solved by adding priority to every row/column and
calculating the high priority row/column first. The algorithm for
adding these priorities is as follows:
@itemize @bullet
  @item Find middle row/column of uncalculated block. Priority is the size
    of the block (in floating point coordinates)
  @item Start function for left block and right block
@end itemize
    
This function produces quite good results. It tends to make same size
rectangles on the whole image and does not depend on resolution.

Another interesting optimization is that during the zoom it is more
advantageous to calculate rows/columns in the center of the zoom
instead of the borders since these will be in the viewport longer and
the user is usually focusing on center of the zoom anyhow.

This is done by simply adding to the calculated priority
@math{normal_priority / (abs(newposition - oldposition) / step + 1)}. This
prefers rows/columns that do not move a great deal. Of course,
unzooming uses the formula reversed.

The last variable to consider is the time interval for one frame.
Setting it too low makes the calculation slow. Setting it too high
makes the framerate too low. So the amount of time spent in other
parts of the program is calculated and multiplied by 5 to determine
the interval. If time is then lower than 15FPS, 15FPS is used instead,
since slower animations are unacceptable. At the other hand if it is higher
than 35FPS, it is set to 35FPS, since higher framerate is just wasting
of computer resources. When image is not animating, this values is changed,
so framerate is choose between 5FPS and 15FPS. This caused that images
are calculated quickly after zooms stops.
   
@section Autopilot

Another interesting algorithm controls the autopilot. It is actually
quite simple. Interesting parts are found at the boundaries of the
set. It randomly looks around and zooms to the first area containing
both outside and inside set points. Some fractals (such as the Newton)
do not have points inside the set at all. In this case it selects a
point where many (more than 2) different colors are around. (i.e., It
zooms into noisy areas.)

In the instance that there are no such areas, the autopilot will
unzoom. Also detects oscillating. 

Current implementation also does detection of out of range numbers and
randomly choosed points are choosed near the old one, to avoid too often
changes of direction.

@section SMP support
Since version 3.0 XaoS supports SMP. This is done using threads. Most of
XaoS routines should be threaded easily---for example moveoldpoints just
divides image into n equal part and each part is proceeded by one processor.
Only unthreaded part is realloc table calculation routines. I don't see any
way to paraelize it except it calculates both---x and y approximation at one
time (using two processors).
Another interesting algorithm to paraelize is boundary trace. See comments
@code{btrace.c} for discussion about current implementation.
Only problem of current implementation I see is possibility, that calculation
is divided into too many parts (realloc tables, move points, calculate,
symmetries, dynamic resolution) and tasks needs to synchronize between each
part. So this should be too slow at real SMP box.

@node timerlib, registry,algorithm ,Top
@chapter The timer library

Timer library is library I did for timing in XaoS. But I found it useful
in many other programs (like demonstrations, games, animation players and
all other stuff that needs to be timed). So you should read this description
and possibly use it in your application and save some coding time.

There is many ways how to design of such timed application (game)

@enumerate
@item
read user input, move badies, display and again
this way has one disadvantage. Speed of game depends on speed of computer.
This was acceptable in old times where only processor was Z80 :) but now
with wide variety of various hardwares such internal loop is unacceptable

@item
read user input, measure time since last loop and calculate step for
badies, move badies for set step, display and again.
This way fixes problem with speed. But moving badies just for calculated
step, that should differ a much is quite complex, usually introduces complex
calculation, floating/fixedpoint math and other unnecesarry stuff that makes
program long and introduces many bugs.

@item
Set the fixed framerate that is high enough to make game smooth but low
enough to do whole internal loop in time. So internal loop should look like:
read user input, move badies, display, measure time spent in loop an
sleep rest of time until next frame.
This is quite popular scheme but has another disadvantage---game can not be
designed to use whole CPU power since on slower computers internal loop should
take longer time that is reserved for one frame. Game will run slowly again.

@item
To take away disadvantage of previous method, many games times just
moving of badies and user input. Other stuff like displaying should be
done in rest of time. In DOS games moving and user input is often at
asynchronous interrupt and drawing runs as main loop. This solves problem
in case that drawing of game takes significantly longer time than moving
of badies. This is quite usual so this scheme works well.

@item
previous scheme still has one problem---since timer interrupt works
asynchronously, there should happend many race condition, in case moving
takes longer time than time reserved from frame, computer can crash. So
this scheme should be enhanced into synchronous one with exactly same result
but avoiding problem with race condition:

read user input, measure time spent by loop and calculate how many simulated
frame interrupts activated since last activation, if zero sleep until
simulated interrupt, move badies as many times as required, display

this is an combination of 4 and 3 and seems to be most comfortable way
for writing games but since main loop is now quite complex many games don't
do that.

@item
there is still one small problem. Method 5 expect that moving takes
significantly lower time that displaying. This may not be truth. Simple
work around is to write moving routine, that should move for x moves
by faster way that calling move x times. This is often possible and makes
easy extension to scheme 5. This scheme allows you to use very large
maximal framerate (say 100FPS) and to have same results as method 2
(that is maximally exact method)
@end enumerate

As you can see, designing of main loop isn't so easy. This is just very
simple example. More advanced application for example should want to move
one set of badies at one framerate and other at different framerate. This
requires two such timings. Another complication is that there is many
different ways to measure time exactly at different platforms. Under Linux
you can measure using gettimeofday but under DOS this is exact just to 1/18
of second and thats too low for smooth animation and so on.

Thats why I decided to design portable easy to use timer library, that
makes easy to implement all described method, combining of them and much more.
During design I taken care at the following thinks: quality of timing,
how easy to use it is, speed, portability and to minimalize inexpected
situations (like race conditions in asynchronous interrupts and so on)

@section The name of game

Timer library operates with @dfn{timers}. They should be created, you should
measure time since last reset, pause them or set @dfn{handler} and @dfn{interval}.
But handler is not activated at given interval yet. Since timer library is
not asynchronous, you must activate them.

For activating is used @dfn{groups}. You should process group at some place in 
your program. Then all timers in group are checked and their handlers
activated if required. When time spent since last activation is higher than
interval, handler is activated more times. Also interval to next invocation is
calculated to keep frequency.  Simple scheduling is performed at handler---handler
is activated just once and then all other timers are checked before it is activated
again. You should also define an multihandler---handler that is activated just once
and receives argument how many intervals has left.

There is two special groups---@code{asyncgroup}. Timers in this group are activated
asynchronously like from interrupt. It is not recommended to use it, since it
brings many problems and usually isn't required. Also it does not work at many
platforms. @code{Syncgroup} is the default group. Program is expected to process is
quite often. In case you don't need to use more groups, you should use this
one.

Time in timerlib is bit strange, since it does not flow continuously but
jumps. It is updated every time you call @code{tl_updatetime}. I used this way in
order to minimize context switches but later I found this scheme very useful,
since you should lookup timer, do something and then reset it and don't wory
about time spend between lookup and reset since it is 0 in case you did not
called tl_updatetime. This helps to keep frequency of timers exact w/o any
errors caused by such situations. At the other hand you need to call
tl_updatetime at least once in your main loop.

Maybe you don't know why to create more groups, but I found it quite useful.
For example an autopilot in XaoS has such special group---I need to call it
approx. every 1/20 of second but just at one place in program. Invoking of
autopilot when calculation is active should produce incorrect results, so I
have special group for autopilot and process just at one place where I am sure
it is safe. 

Timers should be also emulated. You should stop them and then control flow of
time for given timer. This should be quite useful for example when you want
precalculate animation at given framerate.

To control group of timers, you might create @dfn{emulators}. It is just
another time controlled by you. It is useful in cases you want to emulate
fixed framerate (for animation rendering) or such.

@section Time functions

@deftypefn Function void tl_update_time (void)
Update time used by timerlib. This must be called at least once in main loop
otherwise time will not flow. See above.
@end deftypefn
@deftypefn Function void tl_sleep (int @var{time})
Sleep given time. Similar to usleep at POSIX.
@end deftypefn
@section Group functions

@deftypefn Function tl_group* tl_create_group (void)
Allocate and initialize group header. Returns NULL when malloc fails.
@end deftypefn
@deftypefn Function void tl_free_group (tl_group *@var{group})
Free memory storage used by group structure
@end deftypefn
@deftypefn Function int tl_process_group (tl_group *@var{group}, int *@var{activated})
Process timers in group and activates their handlers. Returns time
until next invocation. Main loop should sleep returned time
then. An @var{activated} parameter sould be @code{NULL}. If it is non @code{NULL}, variable
is set to number of activated handlers.
@end deftypefn
@section Timer functions

@deftypefn Function tl_timer* tl_create_timer (void)
Create timer structure.
@end deftypefn
@deftypefn Function void tl_free_timer (tl_timer *@var{timer})
Free memory storage used by timer structure
@end deftypefn
@deftypefn Function void tl_reset_timer (tl_timer *@var{timer});
Reset timer to current time. (time of last actication of @code{tl_update_time})
@end deftypefn
@deftypefn Function int tl_lookup_timer (tl_timer *@var{timer});
Return time since last call of tl_reset_timer or last activation of handler.
@end deftypefn
@deftypefn Function void tl_set_interval (tl_timer *@var{timer}, int @var{interval});
@end deftypefn
@deftypefn Function void tl_set_handler (tl_timer *@var{timer}, void (*@var{handler}) (void *),void *userdata);
@end deftypefn
@deftypefn Function void tl_set_multihandler (tl_timer *@var{timer}, void (*@var{handler}) (void *,int),void *userdata);

Handler, multihandler and interval control functions
@end deftypefn


@deftypefn Function void tl_add_timer (tl_group *@var{group}, tl_timer *@var{timer})
Add timer to given group. Timer should be added into just one group.
@end deftypefn
@deftypefn Function void tl_stop_timer (tl_timer *@var{timer})
@end deftypefn
@deftypefn Function void tl_resume_timer (tl_timer *@var{timer})
Stop and resume timer.
@end deftypefn

@deftypefn Function void tl_slowdown_timer (tl_timer *@var{timer},int @var{time})
Time in timer is moved back for given time.
@end deftypefn

@section Emulator functions
@deftypefn Function struct timeemulator *tl_create_emulator (void);
This function creates new emulator---you need to create one first before
emulating.
@end deftypefn
@deftypefn Function void tl_free_emulator (struct timeemulator *@var{t});
Destroy emulator's data
@end deftypefn
@deftypefn Function void tl_elpased (struct timeemulator *@var{t}, int @var{elpased});
Move emulated time.
@end deftypefn
@deftypefn Function void tl_emulate_timer (struct timer *@var{t}, struct timeemulator *@var{e});
Set timer to the emulated mode. Since now all time is controled by emulator
@var{e}. All other behavior of timer keeps unchanged.
@end deftypefn
@deftypefn Function void tl_unemulate_timer (struct timer *@var{t});
Disable emulated mode for the timer.
@end deftypefn
@section Example main loop

@example
while(1)
@{
  time=tl_process_group(syncgroup,activated); /*Call game control functions*/
  update_keys();
  if(activated) /*something changed*/
    display();
  else tl_sleep(time);
@}
@end example

@node registry, index,timerlib ,Top
@chapter XaoS function registry

XaoS has an ui helper library, which provides functionality provided by user
interface. All it's useful functions are registered into central registry.
This registry is used to generate menus and dialogs as well as command line
options or scripting language. So it is very significant think in XaoS design.

Not only those who want hack XaoS ui-helper layer needs to know this, but also
authors of drivers should use this to add new driver depended functions into
XaoS's menu. Also external user interface is based at this.
Main idea behind external user interfaces (currently one for TCL/Tk and Gtk is under
development) is following: XaoS transfers it's registry to interface (using
simple description language). User interface starts XaoS in it's window
and builds menus and dialogs based at this registry. Then once user select
some function, it creates an command for scripting language and sends it back
to XaoS' engine.

So knowledge of this part is essential for many developers. Please take care
for this part.

The implementation of registry is in file @code{xmenu.c}, header is
@code{xmenu.h}. Mainly for historical reasons it speaks about menus and
dialogs. (It was designed for the GUI at the beginning) I am keeping this
terminology, since it is quite clean and easy to understand instead of talking
in some cryptic abstract term.

@section Function description

To add function into database, you need write it's description into menuitem
structure. It has following prototype:

@findex menuitem
@example
typedef struct menuitem
  @{
    char *menuname;
    char *key;
    char *name;
    char *shortname;
    int type;
    int flags;
    void (*function) ();
    int iparam;
    void *pparam;
    int (*control) (struct uih_context *);
    menudialog *(*dialog) (struct uih_context *);
  @}
menuitem;
@end example

@defvar menuname
Name of menu (or category) function belongs in. The root of all categories is
called @code{"root"}. XaoS alternativly uses an @code{"animroot"} when
animation replay is active. If you are adding an function, it is better to add
it into some subcategory like as @code{"ui"} (it will be placed into UI menu
then) or create an new category for
your functions if needed. It will appear as submenu in main menu in the UI.
@end defvar

@defvar key
Ascii code of hotkey to activate this function. Use @code{NULL} if none.
@end defvar

@defvar name
Longer name of functions used in the menu entry, or @code{xaos --help} listing
@end defvar

@defvar shortname
One-word name of function used in command language and references to function.
@end defvar

@defvar type
type of function---this is not return type. Type should be one of following
constants:
@table @code
@findex MENU_SUBMENU
@item MENU_SUBMENU
   An submenu. This is not real function, but name for submenu. You might fill
   the @var{key}, @var{name}, @var{shortname} functions. An name of this new
   submenu is placed in the field @var{pparam}.
@findex MENU_NOPARAM
@item MENU_NOPARAM
   An normal function without any parameters. When actived, function
   @var{function} with just an pointer to @code{uih_context} will be called.
@findex MENU_INT
@item MENU_INT
   This should be used to simplify entering of more similar functions (handled
   by just one universal function in the c code). This function is handled in
   same way as @code{MENU_NOPARAM}, but also in one integer parameters taken
   from @code{iparam} is passed.
@findex MENU_STRING
@item MENU_STRING
   Similar to @code{MENU_INT} but uses string instead of integer.
@findex MENU_DIALOG
@item MENU_DIALOG
   If you function needs some paramters, use dialog structure to describe
   them. In scripting language your function will have parameters then, in
   user interface dialog will be displayed. @var{pparam} must then point to
   array of dialog entries. Witting them will be described later.
   If your function has just one parameter described in dialog structure, it
   will be called in normal c way---if you want string parameter, one
   pointer pointing to string (in addition to @code{uih_context}) will be
   passed to the functions.

   In case of multiple parameters are requested, it is impossible to call
   function in c way without special wrapper for each such case. So it will
   receive pointer to array of @code{dialogparam} unions, wich contains
   one entry for each parameter. @code{dialogparam} is declared as follows:
@example
typedef union
  @{
    char *dstring;
    int dint;
    number_t number;
    number_t dcoord[2];
    xio_path dpath;
    void *dummy;
  @}
dialogparam;
@end example
@findex MENU_CDIALOG
@item MENU_CDIALOG
   In some cases, it is useful to add some context specific default values
   to the dialog structure. In this case you might use this type instead. In
   this case function @var{dialog} is called first, and it is expected to
   return pointer to correct dialog structure. Dialog structure must lie in
   static storage (since it is not freed) and always must have the same
   fields, just differ in the default values.
   Also this function must work correctly even in the case pointer to
   @code{uih_context} is @code{NULL}, since it is often called in the
   initialization stages (parameter parsing etc.)
@end table
@end defvar
@defvar flags
Flags are used to set additional information about function:
@table @code
@findex MENUFLAG_CHECKBOX
@item MENUFLAG_CHECKBOX
Some features act like check-box---i.e. by one calling of function they are
enabled, second call disables this. In menu it is useful to add an check-box
for this function indicating whether feature is on or off.

And thats exactly what this flag does :). You need also define the function
@var{control} wich return's @code{1} when enabled and @code{0} when disabled.
In order to let external GUI's work correctly you need also call
@code{uih_updatemenus("name")} every time state of this function changes.

In the scripting language this adds an first parameter, wich if @code{#t} or @code{#f}.
Engine then calls function just when it is necessary. For @code{#t} dialog is
requested, with @code{#f} function is called just as @code{NOPARAM}. I.e.
dialog is displayed just when enabling feature.

@findex MENUFLAG_DIALOGATDISABLE
@item MENUFLAG_DIALOGATDISABLE 
In checkbox display dialog when this feature is disabled instead when enabled.
@findex MENUFLAG_RADIO
@item MENUFLAG_RADIO
Other features act like radio-button. Control function in this case receives
same parameter as defined for @code{MENU_INT} or @code{MENU_STRING} types and
is expected to return @code{1} when enabled. You also need to call
@code{uih_updatemenus} when changed. No special parameter is added in the
scripting language.

@findex MENUFLAG_INTERRUPT
@item MENUFLAG_INTERRUPT
Interrupt current calculation when this function called (it is used by
functions with causes recalculation of screen)

@findex MENUFLAG_INCALC
@item MENUFLAG_INCALC
By default XaoS queues functions and calls later when they are activated
in caluclation. This flag disables this feature.
@findex MENUFLAG_ATSTARTUP
@item MENUFLAG_ATSTARTUP
By default XaoS queues functions and calls later when they are activated
as command line parameters (in time engine is not fully initialized yet).
This flag disables this feature.
@findex MENUFLAG_NOMENU
@item MENUFLAG_NOMENU
Function will not be visible in the menu
@findex MENUFLAG_NOPLAY
@item MENUFLAG_NOPLAY
Function will not be available as command in scripts
@findex MENUFLAG_NOOPTION
@item MENUFLAG_NOOPTION
Function will not be available as command line option
@end table
@end defvar


@section Initializing menuitem structure as static variable
In most case menuitems should be wrote as static variables. Because contents
of this structure should change in future, please use one of macros defined
in @code{xmenu.h}. They provides cleaner and easier to extend way to define 
this entries.

For example to define @code{MENU_NOPARAM} function use following macro:
@defun MENUNOP (menuname, key, name, shortname, flags, function)
@end defun
Similar macros exist for the other types too. They ends for @code{CB} or
@code{RB} for check-boxed or radio-boxes functions. See @code{menu.c} for large
example of definitions. They should look like this:

@findex menuitem
@example
static menuitem menuitems[] =   /*XaoS menu specifications */
@{
  SUBMENU ("", NULL, "Root menu", "root"),
  SUBMENU ("", NULL, "Replay only commands", "plc"),
  MENUNOP ("comm", NULL, "print menus specifications of all menus",
           "print_menus", MENUFLAG_NOMENU|MENUFLAG_NOPLAY|MENUFLAG_ATSTARTUP,
           uih_printallmenus),
           ...
@end example

@section Dialog description
Dialog description is similar to menuitem. It is array of following
structures:
@example
typedef struct dialog
  @{
    char *question;
    int type;
    int defint;
    char *defstr;
    number_t deffloat;
    number_t deffloat2;
  @}
menudialog;
@end example
It is terminated by @var{question} pointer set to @code{NULL}.

The @var{question} contains string ui should display when is asking for this
field.

@var{type} should be one of following values:
@code{DIALOG_INT}, @code{DIALOG_FLOAT}, @code{DIALOG_STRING},
@code{DIALOG_KEYSTRING} (the difference between string and keystring is, that
in scripting language string is passed as @code{"hello"}, but keystring is passed as
scheme keyword as @code{'hello}), @code{DIALOG_IFILE} (input file),
@code{DIALOG_OFILE}, @code{DIALOG_CHOICE} (choice between different
keystrings), @code{DIALOG_ONOFF} (boolean parameter), @code{DIALOG_COORD} (two
floats---complex number)

Set to corresponding @var{def*} field for default value. In case of files use
string in the format @code{"@var{[prefix]}*@var{[extension]}"}. For type
@code{DIALOG_CHOICE} set @var{defstr} to pointer to array of strings
terminated by @code{NULL} entry.

To write dialog structures again use macros defined in @code{xmenu.h} like:
@example
DIALOGSTR(question,default)
@end example
The definition should look like:

@findex menudialog
@example
static menudialog uih_viewdialog[] =
@{
  DIALOGCOORD ("center:", 0, 0),
  DIALOGFLOAT ("Radius:", 1),
  DIALOGFLOAT ("Angle:", 0),
  @{NULL@}
@};
@end example
@section Modifying registry
@deftypefn Function void menu_add (menuitem *@var{item}, int @var{n});
Add array of @var{n} items to the database.
@end deftypefn
@deftypefn Function void menu_delete (menuitem *@var{items}, int @var{n});
Remove array of @var{n} items from database.
@end deftypefn
@section Querying registry
@deftypefn Function menuitem* menu_findkey (char *@var{key}, char *@var{root});
Find item for given key. @var{root} is menu where to start (submenus are
searched recursively)
@end deftypefn
@deftypefn Function menuitem* menu_findcommand (char *@var{name});
Find item for given short name
@end deftypefn
@deftypefn Function char* menu_fullname (char *@var{menu}); 
Long name for the short name of menu
@end deftypefn
@deftypefn Function menuitem* menu_item (char *@var{menu}, int @var{n}); 
@var{N}th entry of the @var{menu}. Return @code{NULL} if no more entries
available.
@end deftypefn
@deftypefn Function int menu_enabled (menuitem *@var{item}, struct uih_context *@var{c}); 
Check whether given item is activated (for check-boxed and radio-boxed functions)
@end deftypefn
@deftypefn Function int menu_havedialog (menuitem *@var{item}, struct uih_context *@var{c});
Does this function have dialog?
@end deftypefn
@defun menu_getdialog (@var{context}, @var{m})
Macro returns pointer to dialog structure. (function must have it, otherwise
garbage is returned).
@end defun
@deftypefn Function int menu_available (menuitem *@var{item}, char *@var{root});
Check whether item is available as one of entries of @var{root} (or it's
submenus)
@end deftypefn

@node    index,     , registry, Top
@c        node-name,    next, previous,        up
@unnumbered Index of functions, variables, types and constants

@printindex fn

@contents
@bye
